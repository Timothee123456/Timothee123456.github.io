<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HSK Study App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .word-card {
            transition: all 0.3s ease;
        }
        .word-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .flashcard {
            perspective: 1000px;
        }
        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }
        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 1rem;
            padding: 2rem;
        }
        .flashcard-back {
            transform: rotateY(180deg);
        }
        .word-list-container {
            height: calc(100vh - 280px);
            overflow-y: auto;
        }

        .word-item {
            transition: background-color 0.2s ease;
        }

        .word-item:hover {
            opacity: 0.8;
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #181818;
                color: #ffffff;
            }
        }
    </style>
</head>
<body class="min-h-screen bg-white dark:bg-[#181818] text-gray-900 dark:text-white transition-colors">

    <!-- Level Selection Screen -->
    <div id="levelSelection" class="min-h-screen flex items-center justify-center p-4">
        <div class="max-w-md w-full">
            <h1 class="text-4xl font-bold text-center mb-8 text-[#5D5CDE]">HSK Study App</h1>
            <p class="text-center mb-6 text-gray-600 dark:text-gray-400">Select your HSK level to begin</p>
            <div class="space-y-4">
                <button onclick="selectLevel(1)" class="w-full py-4 px-6 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-xl font-semibold transition">HSK 1</button>
                <button onclick="selectLevel(2)" class="w-full py-4 px-6 bg-green-500 hover:bg-green-600 text-white rounded-lg text-xl font-semibold transition">HSK 2</button>
                <button onclick="selectLevel(3)" class="w-full py-4 px-6 bg-yellow-500 hover:bg-yellow-600 text-white rounded-lg text-xl font-semibold transition">HSK 3</button>
            </div>
        </div>
    </div>

    <!-- Main Study Screen -->
    <div id="mainScreen" class="hidden min-h-screen p-4">
        <div class="max-w-7xl mx-auto">
            <!-- Header -->
            <div class="flex justify-between items-center mb-6">
                <div>
                    <h1 class="text-3xl font-bold text-[#5D5CDE]">HSK Study</h1>
                    <p class="text-gray-600 dark:text-gray-400">Level <span id="currentLevel"></span></p>
                </div>
                <button onclick="resetLevel()" class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition text-base">Change Level</button>
            </div>

            <!-- Action Buttons -->
            <div class="flex gap-4 mb-6">
                <button onclick="startLearn()" class="flex-1 py-3 px-6 bg-[#5D5CDE] hover:bg-[#4D4CCE] text-white rounded-lg text-lg font-semibold transition">
                    Learn
                </button>
                <button id="reviseBtn" onclick="startRevise()" class="flex-1 py-3 px-6 bg-green-600 hover:bg-green-700 text-white rounded-lg text-lg font-semibold transition disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                    Revise (<span id="knownCount">0</span> known)
                </button>
            </div>

            <!-- Word Lists - Side by Side -->
            <div class="grid grid-cols-3 gap-4">
                <!-- Unknown Words -->
                <div class="bg-red-50 dark:bg-red-900/20 border-2 border-red-200 dark:border-red-800 rounded-lg p-4">
                    <h2 class="text-xl font-bold text-red-700 dark:text-red-400 mb-4">Unknown Words (<span id="unknownCount">0</span>)</h2>
                    <div id="unknownWords" class="word-list-container space-y-2"></div>
                </div>

                <!-- Half-Known Words -->
                <div class="bg-yellow-50 dark:bg-yellow-900/20 border-2 border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
                    <h2 class="text-xl font-bold text-yellow-700 dark:text-yellow-400 mb-4">Half-Known Words (<span id="halfKnownCount">0</span>)</h2>
                    <div id="halfKnownWords" class="word-list-container space-y-2"></div>
                </div>

                <!-- Known Words -->
                <div class="bg-green-50 dark:bg-green-900/20 border-2 border-green-200 dark:border-green-800 rounded-lg p-4">
                    <h2 class="text-xl font-bold text-green-700 dark:text-green-400 mb-4">Known Words (<span id="knownCount2">0</span>)</h2>
                    <div id="knownWords" class="word-list-container space-y-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Flashcard Modal -->
    <div id="flashcardModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full p-6">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold" id="modeTitle">Learn Mode</h2>
                <div class="text-lg font-semibold">
                    <span id="currentCard">1</span> / <span id="totalCards">10</span>
                </div>
            </div>

            <!-- Flashcard -->
            <div class="flashcard mb-6" id="flashcard" style="height: 300px;">
                <div class="flashcard-inner">
                    <div class="flashcard-front bg-[#5D5CDE] text-white">
                        <div>
                            <div class="text-6xl font-bold mb-4" id="cardChinese"></div>
                            <div class="text-xl" id="cardPinyin"></div>
                        </div>
                    </div>
                    <div class="flashcard-back bg-gray-100 dark:bg-gray-700">
                        <div>
                            <div class="text-4xl font-bold mb-4 text-gray-900 dark:text-white" id="cardEnglish"></div>
                            <div class="text-xl text-gray-600 dark:text-gray-400" id="cardPinyinBack"></div>
                            <div class="text-2xl text-gray-800 dark:text-gray-200 mt-2" id="cardChineseBack"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="space-y-4">
                <button onclick="flipCard()" class="w-full py-3 px-6 bg-gray-500 hover:bg-gray-600 text-white rounded-lg text-lg font-semibold transition">
                    Flip Card
                </button>
                <div class="grid grid-cols-2 gap-4">
                    <button onclick="markCard(false)" class="py-3 px-6 bg-red-500 hover:bg-red-600 text-white rounded-lg text-lg font-semibold transition">
                        ✗ Incorrect
                    </button>
                    <button onclick="markCard(true)" class="py-3 px-6 bg-green-500 hover:bg-green-600 text-white rounded-lg text-lg font-semibold transition">
                        ✓ Correct
                    </button>
                </div>
                <button onclick="closeFlashcards()" class="w-full py-2 px-4 bg-gray-400 hover:bg-gray-500 text-white rounded-lg transition text-base">
                    Exit
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import HSK vocabulary data from external files
        import { hsk1 } from './hsk1.js';
        import { hsk2 } from './hsk2.js';
        import { hsk3 } from './hsk3.js';

        // Dark mode setup
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // HSK Vocabulary Data (now compiled from imports)
        const hskData = {
            1: hsk1,
            2: hsk2,
            3: hsk3
        };

        // State management
        let selectedLevel = 0;
        let allWords = [];
        let wordProgress = {}; // { wordId: { status: 'unknown'|'half'|'known', firstCorrect: timestamp, lastCorrect: timestamp } }
        let currentDeck = [];
        let currentCardIndex = 0;
        let isFlipped = false;
        let currentMode = 'learn';

        // HSK Level colors
        const levelColors = {
            1: 'bg-blue-200 dark:bg-blue-800',
            2: 'bg-green-200 dark:bg-green-800',
            3: 'bg-yellow-200 dark:bg-yellow-800'
        };

        // Cookie management
        function setCookie(name, value, days) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = name + '=' + JSON.stringify(value) + ';expires=' + expires.toUTCString() + ';path=/';
        }

        function getCookie(name) {
            const nameEQ = name + '=';
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) {
                    try {
                        return JSON.parse(c.substring(nameEQ.length, c.length));
                    } catch (e) {
                        return null;
                    }
                }
            }
            return null;
        }

        function saveProgress() {
            setCookie('hskLevel', selectedLevel, 365);
            setCookie('hskProgress', wordProgress, 365);
        }

        function loadProgress() {
            const level = getCookie('hskLevel');
            const progress = getCookie('hskProgress');

            if (level) {
                selectedLevel = level;
                // We need to ensure hskData is loaded before calling selectLevel
                // For simplicity, we assume the module script runs after imports are ready.
                // In a real app, you might want to await module loading or use a different pattern.
                selectLevel(level, false);
            }
            if (progress) {
                wordProgress = progress;
                // Only update word lists if a level has been selected
                if (selectedLevel > 0) {
                    updateWordLists();
                }
            }
        }

        // Level selection
        function selectLevel(level, shouldSave = true) {
            selectedLevel = level;

            // Load all words from level 1 to selected level
            allWords = [];
            for (let i = 1; i <= level; i++) {
                if (hskData[i]) { // Ensure the level data exists
                    hskData[i].forEach((word, index) => {
                        allWords.push({
                            ...word,
                            level: i,
                            id: `hsk${i}_${index}`
                        });
                    });
                }
            }

            // Initialize progress for new words
            allWords.forEach(word => {
                if (!wordProgress[word.id]) {
                    wordProgress[word.id] = {
                        status: 'unknown',
                        firstCorrect: null,
                        lastCorrect: null
                    };
                }
            });

            if (shouldSave) {
                saveProgress();
            }

            document.getElementById('levelSelection').classList.add('hidden');
            document.getElementById('mainScreen').classList.remove('hidden');
            document.getElementById('currentLevel').textContent = level;

            updateWordLists();
        }

        function resetLevel() {
            document.getElementById('mainScreen').classList.add('hidden');
            document.getElementById('levelSelection').classList.remove('hidden');
        }

        // Update word lists
        function updateWordLists() {
            const unknown = [];
            const halfKnown = [];
            const known = [];

            allWords.forEach(word => {
                const progress = wordProgress[word.id];
                if (progress.status === 'known') {
                    known.push(word);
                } else if (progress.status === 'half') {
                    halfKnown.push(word);
                } else {
                    unknown.push(word);
                }
            });

            renderWordList('unknownWords', unknown);
            renderWordList('halfKnownWords', halfKnown);
            renderWordList('knownWords', known);

            document.getElementById('unknownCount').textContent = unknown.length;
            document.getElementById('halfKnownCount').textContent = halfKnown.length;
            document.getElementById('knownCount').textContent = known.length;
            document.getElementById('knownCount2').textContent = known.length;

            // Enable/disable revise button
            const reviseBtn = document.getElementById('reviseBtn');
            if (known.length >= 10) {
                reviseBtn.disabled = false;
            } else {
                reviseBtn.disabled = true;
            }
        }

        function renderWordList(containerId, words) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            words.forEach(word => {
                const item = document.createElement('div');
                item.className = `word-item ${levelColors[word.level]} rounded-lg p-3 shadow-sm flex justify-between items-center`;
                item.innerHTML = `
                    <div class="flex-1 min-w-0">
                        <div class="text-lg font-bold text-gray-900 dark:text-white">${word.chinese}</div>
                        <div class="text-sm text-gray-700 dark:text-gray-300">${word.pinyin}</div>
                    </div>
                    <div class="text-sm text-gray-600 dark:text-gray-400 text-right ml-2">${word.english}</div>
                `;
                container.appendChild(item);
            });
        }

        // Flashcard functionality
        function startLearn() {
            currentMode = 'learn';
            document.getElementById('modeTitle').textContent = 'Learn Mode';

            const unknown = allWords.filter(w => wordProgress[w.id].status === 'unknown');
            const halfKnown = allWords.filter(w => wordProgress[w.id].status === 'half');
            const known = allWords.filter(w => wordProgress[w.id].status === 'known');

            currentDeck = [];

            // Prioritize unknown and half-known words for learning
            // Aim for a mix, but ensure we cover new words
            const maxDeckSize = 10;
            let tempDeck = [];

            // Add unknown words first
            const shuffledUnknown = [...unknown].sort(() => Math.random() - 0.5);
            tempDeck.push(...shuffledUnknown.slice(0, Math.min(shuffledUnknown.length, maxDeckSize / 2))); // Up to half the deck from unknown

            // Fill remaining with half-known words
            const shuffledHalfKnown = [...halfKnown].sort(() => Math.random() - 0.5);
            tempDeck.push(...shuffledHalfKnown.slice(0, maxDeckSize - tempDeck.length));

            // If still space, add some known words (less priority)
            if (tempDeck.length < maxDeckSize && known.length > 0) {
                const shuffledKnown = [...known].sort(() => Math.random() - 0.5);
                tempDeck.push(...shuffledKnown.slice(0, maxDeckSize - tempDeck.length));
            }

            currentDeck = tempDeck.slice(0, maxDeckSize); // Final limit to 10

            // Shuffle the final deck
            currentDeck.sort(() => Math.random() - 0.5);


            if (currentDeck.length === 0) {
                showCustomAlert('No words available for learning! Try selecting a different level or you\'ve learned them all.');
                return;
            }

            startFlashcards();
        }

        function startRevise() {
            currentMode = 'revise';
            document.getElementById('modeTitle').textContent = 'Revise Mode';

            const known = allWords.filter(w => wordProgress[w.id].status === 'known');

            if (known.length < 10) {
                showCustomAlert('You need at least 10 known words to revise!');
                return;
            }

            // Get 10 random known words
            const shuffled = [...known].sort(() => Math.random() - 0.5);
            currentDeck = shuffled.slice(0, 10);

            startFlashcards();
        }

        function startFlashcards() {
            currentCardIndex = 0;
            document.getElementById('flashcardModal').classList.remove('hidden');
            document.getElementById('totalCards').textContent = currentDeck.length;
            showCard(0);
        }

        function showCard(index) {
            if (index >= currentDeck.length) {
                closeFlashcards();
                updateWordLists();
                saveProgress();
                showCustomAlert('Session complete!');
                return;
            }

            const word = currentDeck[index];
            isFlipped = false;
            document.getElementById('flashcard').classList.remove('flipped');

            document.getElementById('currentCard').textContent = index + 1;
            document.getElementById('cardChinese').textContent = word.chinese;
            document.getElementById('cardPinyin').textContent = word.pinyin;
            document.getElementById('cardEnglish').textContent = word.english;
            document.getElementById('cardPinyinBack').textContent = word.pinyin;
            document.getElementById('cardChineseBack').textContent = word.chinese;
        }

        function flipCard() {
            isFlipped = !isFlipped;
            document.getElementById('flashcard').classList.toggle('flipped');
        }

        function markCard(correct) {
            const word = currentDeck[currentCardIndex];
            const progress = wordProgress[word.id];
            const now = Date.now();

            if (correct) {
                if (progress.status === 'unknown') {
                    // First correct answer
                    progress.status = 'half';
                    progress.firstCorrect = now;
                    progress.lastCorrect = now;
                } else if (progress.status === 'half') {
                    // Check if 24 hours have passed since first correct
                    // For demonstration, we'll make this simpler: 2 correct in a row or 2 correct overall
                    // A more robust SRS would use spaced repetition algorithms (e.g., SM-2)
                    // For now, let's say if it's been half-known and marked correct, it moves to known.
                    // Or, if you want a time component, keep the 24-hour check.
                    // Let's simplify for this example: one correct after 'half' moves it to 'known'.
                    // To keep the original logic, I'll retain the 24-hour check.
                    const hoursSinceFirst = (now - progress.firstCorrect) / (1000 * 60 * 60);
                    if (hoursSinceFirst >= 24) { // Original logic: needs 24 hours to pass
                        progress.status = 'known';
                        progress.lastCorrect = now;
                    } else {
                        // Not enough time has passed, keep as half, update last correct
                        progress.lastCorrect = now;
                    }
                } else if (progress.status === 'known') {
                    // Update last correct time for known words
                    progress.lastCorrect = now;
                }
            } else { // Marked Incorrect
                // If a known or half-known word is marked incorrect, move it back to unknown.
                // This is a simple strategy; a real SRS might have more nuanced demotion.
                if (progress.status === 'half' || progress.status === 'known') {
                    progress.status = 'unknown';
                    progress.firstCorrect = null; // Reset first correct for re-learning
                    progress.lastCorrect = null;
                }
                // If already unknown, it stays unknown.
            }

            currentCardIndex++;
            showCard(currentCardIndex);
        }

        function closeFlashcards() {
            document.getElementById('flashcardModal').classList.add('hidden');
            updateWordLists();
            saveProgress();
        }

        // Custom alert function (replacing browser alert)
        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-[#5D5CDE] text-white hover:bg-[#4D4CCE] rounded" onclick="this.closest('.fixed').remove()">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Initialize on load
        // Defer loadProgress slightly to ensure hskData is fully populated from modules
        window.addEventListener('DOMContentLoaded', loadProgress);
    </script>
</body>
</html>